%% For double-blind review submission, w/o CCS and ACM Reference (max submission space)
% \documentclass[acmsmall,review, anonymous]{acmart}\settopmatter{printfolios=true,printccs=false,printacmref=false}
%% For double-blind review submission, w/ CCS and ACM Reference
%\documentclass[acmsmall,review,anonymous]{acmart}\settopmatter{printfolios=true}
%% For single-blind review submission, w/o CCS and ACM Reference (max submission space)
\documentclass[acmsmall,review]{acmart}\settopmatter{printfolios=true,printccs=false,printacmref=false}
%% For single-blind review submission, w/ CCS and ACM Reference
%\documentclass[acmsmall,review]{acmart}\settopmatter{printfolios=true}
%% For final camera-ready submission, w/ required CCS and ACM Reference
%\documentclass[acmsmall]{acmart}\settopmatter{}


%% Journal information
%% Supplied to authors by publisher for camera-ready submission;
%% use defaults for review submission.
\acmJournal{PACMPL}
\acmVolume{1}
\acmNumber{OOPSLA} % CONF = POPL or ICFP or OOPSLA
\acmArticle{1}
\acmYear{2023}
\acmMonth{1}
\acmDOI{10.1145/nnnnnnn.nnnnnnn} % \acmDOI{10.1145/nnnnnnn.nnnnnnn}
\startPage{1}

%% Copyright information
%% Supplied to authors (based on authors' rights management selection;
%% see authors.acm.org) by publisher for camera-ready submission;
%% use 'none' for review submission.
\setcopyright{none}
%\setcopyright{acmcopyright}
%\setcopyright{acmlicensed}
%\setcopyright{rightsretained}
%\copyrightyear{2018}           %% If different from \acmYear

%% Bibliography style
\bibliographystyle{ACM-Reference-Format}
%% Citation style
%% Note: author/year citations are required for papers published as an
%% issue of PACMPL.
\citestyle{acmauthoryear}   %% For author/year citations


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Note: Authors migrating a paper from PACMPL format to traditional
%% SIGPLAN proceedings format must update the '\documentclass' and
%% topmatter commands above; see 'acmart-sigplanproc-template.tex'.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%% Some recommended packages.
\usepackage{booktabs}   %% For formal tables:
                        %% http://ctan.org/pkg/booktabs
\usepackage{subcaption} %% For complex figures with subfigures/subcaptions
                        %% http://ctan.org/pkg/subcaption

\usepackage{meu}

\begin{document}

%% Title information
\title{Exploiting Factorization For Scaling Decision-Theoretic Probabilistic Programs}         %% [Short Title] is optional;
                                        %% when present, will be used in
                                        %% header instead of Full Title.
% \titlenote{with title note}             %% \titlenote is optional;
%                                         %% can be repeated if necessary;
%                                         %% contents suppressed with 'anonymous'
% \subtitle{Subtitle}                     %% \subtitle is optional
% \subtitlenote{with subtitle note}       %% \subtitlenote is optional;
%                                         %% can be repeated if necessary;
%                                         %% contents suppressed with 'anonymous'


%% Author information
%% Contents and number of authors suppressed with 'anonymous'.
%% Each author should be introduced by \author, followed by
%% \authornote (optional), \orcid (optional), \affiliation, and
%% \email.
%% An author may have multiple affiliations and/or emails; repeat the
%% appropriate command.
%% Many elements are not rendered, but should be provided for metadata
%% extraction tools.

%% Author with single affiliation.
% \author{First1 Last1}
% \authornote{with author1 note}          %% \authornote is optional;
%                                         %% can be repeated if necessary
% \orcid{nnnn-nnnn-nnnn-nnnn}             %% \orcid is optional
% \affiliation{
%   \position{Position1}
%   \department{Department1}              %% \department is recommended
%   \institution{Institution1}            %% \institution is required
%   \streetaddress{Street1 Address1}
%   \city{City1}
%   \state{State1}
%   \postcode{Post-Code1}
%   \country{Country1}                    %% \country is recommended
% }
% \email{first1.last1@inst1.edu}          %% \email is recommended

% %% Author with two affiliations and emails.
% \author{First2 Last2}
% \authornote{with author2 note}          %% \authornote is optional;
%                                         %% can be repeated if necessary
% \orcid{nnnn-nnnn-nnnn-nnnn}             %% \orcid is optional
% \affiliation{
%   \position{Position2a}
%   \department{Department2a}             %% \department is recommended
%   \institution{Institution2a}           %% \institution is required
%   \streetaddress{Street2a Address2a}
%   \city{City2a}
%   \state{State2a}
%   \postcode{Post-Code2a}
%   \country{Country2a}                   %% \country is recommended
% }
% \email{first2.last2@inst2a.com}         %% \email is recommended
% \affiliation{
%   \position{Position2b}
%   \department{Department2b}             %% \department is recommended
%   \institution{Institution2b}           %% \institution is required
%   \streetaddress{Street3b Address2b}
%   \city{City2b}
%   \state{State2b}
%   \postcode{Post-Code2b}
%   \country{Country2b}                   %% \country is recommended
% }
% \email{first2.last2@inst2b.org}         %% \email is recommended

\author{Minsung Cho}
\affiliation{
  \institution{Northeastern University}            %% \institution is required
  \city{Boston}
  \state{Massachusetts}
  \country{USA}                    %% \country is recommended
}
\email{minsung@ccs.neu.edu}          %% \email is recommended

\author{Steven Holtzen}
\affiliation{
  \institution{Northeastern University}            %% \institution is required
  \city{Boston}
  \state{Massachusetts}
  \country{USA}                    %% \country is recommended
}
\email{s.holtzen@northeastern.edu}          %% \email is recommended

%% Abstract
%% Note: \begin{abstract}...\end{abstract} environment must come
%% before \maketitle command
\begin{abstract}
Abstract TBW
\end{abstract}


%% 2012 ACM Computing Classification System (CSS) concepts
%% Generate at 'http://dl.acm.org/ccs/ccs.cfm'.
\begin{CCSXML}
<ccs2012>
<concept>
<concept_id>10011007.10011006.10011008</concept_id>
<concept_desc>Software and its engineering~General programming languages</concept_desc>
<concept_significance>500</concept_significance>
</concept>
<concept>
<concept_id>10003456.10003457.10003521.10003525</concept_id>
<concept_desc>Social and professional topics~History of programming languages</concept_desc>
<concept_significance>300</concept_significance>
</concept>
</ccs2012>
\end{CCSXML}

\ccsdesc[500]{Software and its engineering~General programming languages}
\ccsdesc[300]{Social and professional topics~History of programming languages}
%% End of generated code


%% Keywords
%% comma separated list
\keywords{}  %% \keywords are mandatory in final camera-ready submission


%% \maketitle
%% Note: \maketitle command must come after title commands, author
%% commands, abstract environment, Computing Classification System
%% environment and commands, and keywords command.
% \maketitle

\section{Preliminary definitions, examples, and lemmata}

\begin{definition}
  A \textbf{branch-and-bound algebra} is a semiring $\mathcal S = (S, + , \times, 0 ,1)$ equipped with orders $(\leq, \sqsubseteq)$ such that:
  \begin{enumerate}
    \item $(S, \leq)$ is a total order,
    \item $(S, \sqsubseteq)$ is a join--semilattice with join $\sqcup$ where:
      \begin{enumerate}
        \item $\sqsubseteq$ respects $+,\times$,
        \item For all $s \in S$, $0 \sqsubseteq s$, 
      \end{enumerate}
    \item $\leq, \sqsubseteq$ are \textit{compatible} in the sense that for all $a \sqsubseteq b$, we also have $a \leq b$. We will henceforth call this \textbf{compatibility}.
  \end{enumerate}
\end{definition}

\begin{example}
  The nonnegative real numbers $\R^{\geq 0}$ forms a branch-and-bound algebra with the usual semiring structure of $\R^{\geq 0}$ and the usual order serving as both $\leq$ and $\sqsubseteq$, with join being the $\max$ function. The standard extension $\R^{\geq 0} \cup \{\infty\}$ is also a branch-and-bound algebra with the usual extended operations.
\end{example}

\begin{example}
  The Boolean semiring $\mathbb B = \{\top, \bot\}$ with $+ = \lor, \times = \land, 0 = \bot, 1 = \top$ forms a branch-and-bound algebra with the order $\bot \leq \top$ with join $\land$. 
\end{example}


\begin{example}
  The expected utility semiring $\R^{\geq 0} \times \R$ with the usual semiring operations forms a branch-and-bound algebra with:
  \begin{enumerate}
    \item $(p,u) \leq (q,v)$ iff $u \leq v$ or $u=v$ and $p \leq q$ 
    \item $(p,u) \sqsubseteq (q,v)$ iff $p \leq q$ and $u \leq v$, with join being a coordinatewise max.
  \end{enumerate} 
  It is straightforward to see that these are compatible.
\end{example}

\begin{example}
  For any branch-and-bound algebra $\mathcal B = (\mathcal B, 0, 1, +, \times, \leq, \sqsubseteq)$ consider the collection of finite sets with elements in $\mathcal B$, $\mathcal P_{<\omega} (\mathcal B)$. This forms a semiring with additive and multiplicative identities $\{0\}, \{1\}$ with:
  \begin{enumerate}
    \item $A + B = \cup_{A,B} \{a+b\}$,
    \item $A \times B = \cup_{A,B} \{a \times b\}$.
  \end{enumerate}
  Moreover it becomes a branch-and-bound algebra with:
  \begin{enumerate}
    \item $A \leq B$ iff $\max A \leq \max B$, where $\max$ is the greatest in the set with respect to $\leq$, 
    \item $A \sqsubseteq B$ iff for all $a \in A$ there exists $b \in B$ with $a \sqsubseteq b$, with join 
    \begin{equation}
      A \sqcup B = \cup_{A,B} \begin{cases}
        a & a \sqcup b = a \\ 
        b & a \sqcup b = b \\
        \{a,b\} & else.
      \end{cases}
    \end{equation}
  \end{enumerate}
\end{example}

The intuition here is that $\leq$ is a total order that allows for a selection between "fully evaluated" values and $\sqsubseteq$ is a partial order that allows for comparisons between "partially evaluated" values. The compatibility condition is effectively saying that "comparable partially evaluated values will stay comparable once fully evaluated".

\begin{definition}\label{MSP JSP}
  Let $X$ be a set and $Y(X)$ a set disjoint but possibly dependent on $X$. $\mathcal B$ a branch-and-bound algebra. Let $f : X \times Y \to \mathcal B$ be a function. Then the \textbf{max-sum problem (MSP)} associated to $f$ is
  \begin{equation}\label{MSP}
    \max_{x \in X} \sum_{y \in Y(X)} f(x,y).
  \end{equation}
  where $\max$ is taken with respect to the total order $\leq$ of the branch and bound algebra. Relatedly, the \textbf{join-sum problem (JSP)} associated to $f$ is 
  \begin{equation}\label{JSP}
    \bigsqcup_{x \in X} \sum_{y \in Y(X)} f(x,y).
  \end{equation}
\end{definition}

\begin{example}
  The marginal MAP problem is the MSP problem with $X = inst(M)$ instantiations of MAP variables, $Y = inst(V)$ instantiations of the marginal variables, and $$f(m,v) = \Pr(M=m, V=v \ |\  E=e).$$
\end{example}

\begin{example}
  The maximum expected utility problem is the MSP problem with $X = \pi$ policies, $Y = E$ the event in which the policy $x \in X$ was taken, and 
    $$f(\pi, E) = \sum_{\omega \in E} \Pr(\omega) U(\omega)$$
  where $U(\omega)$ is additive coordinatewise if $\omega$ if the probability distribution is a joint distribution.
\end{example}

\begin{example}
  The weak weighted SAT problem asks for a boolean formula $\varphi$ over variables $V$ the maximum numbers of true variables in a satisfying assignment. This the MSP problem with $X = inst(V)$, $Y = V$, and 
  $$f(x,v) = \begin{cases}
    1 & x(v) = \top , \\ 0 & x(v) = \bot
  \end{cases}$$
  if $\varphi(x)$ is SAT and $f(x, \_) = 0$ if $\varphi(x)$ is UNSAT.
\end{example}

\begin{lemma}[JSP is weak MSP\footnote{One may think that this is reminiscent of weak duality. Unfortunately weak duality is completely irrelevant to this Lemma and is only used for namesake purposes.}]\label{weak}
  Let $X,Y$ be disjoint and $\mathcal B$ a branch-and-bound algebra. Let $f : X \times Y \to \mathcal B$ be a function. Let $MSP$, $JSP$ be the max-sum problem and the join-sum problem with respect to $f$ as in \ref{MSP JSP}. Then we have
  \begin{equation}
    MSP \leq JSP.
  \end{equation}
\end{lemma}

\begin{proof}
  It suffices to show for all $a,b \in \mathcal B$, $\max \{a,b\} \leq a \sqcup b$. Note that $\max\{a,b\}=a$ or $=b$; by definition of join we have $a,b \sqsubseteq a \sqcup b$; by compatibility we are done.
\end{proof}

For the following definition we write for $V$ a set of Boolean variables $inst(V)$ the set of instantiations of $V$ and $lits(V)$ the set of literals of $V$. We write $m \models \varphi$ to denote that $m$ is an instantiation of the variables of $\varphi$ such that the evaluation is true.

\begin{definition}\label{BMSP BJSP}
  Let $\varphi$ be a Boolean formula over variables $V$ and let $X \subseteq V$ a subsest of variables. . Let $\mathcal B$ a branch-and-bound algebra. Let $f: inst(V) \to \mathcal B$ a function. Then the \textbf{Boolean max-sum problem} is
  \begin{equation}\label{BMSP}
    MSP(\varphi) = \max_{x \in inst(X)} \sum_{m \models \varphi|_x} f(x,m)
  \end{equation}
  where $\max$ is taken with respect to the total order $\leq$ of the branch and bound algebra. Relatedly, the \textbf{join-sum problem (JSP)} associated to $f$ is 
  \begin{equation}\label{BJSP}
    JSP(\varphi) = \bigsqcup_{x \in inst(X)} \sum_{m \models \varphi|_x} f(x,m).
  \end{equation}
  We call the problems \emph{factorizable} if there exists a weight function $w : lits(V) \to \mathcal B$ such that for all instantiations $v$ of $V$ it is that
  \begin{equation}\label{factor}
    f(v) = \prod_{\ell \in v} w(\ell).
  \end{equation}
\end{definition}

It is easy to see that Definition \ref{BMSP BJSP} is a special case of Definition \ref{MSP JSP}, thus Lemma \ref{weak} specializes.


\section{Solving factorizable Boolean max-sum problems exactly through branch-and-bound search}

\subsection{Interlude on notation and related lemmata}

We assume from this point forward that we are working with max-sum and join-sum problems strictly in the Boolean setting where the objective function (that is, $f$ in Defintion \ref{MSP JSP}) is factorizable into a weight function over literals $w$. When $f$ and $w$ are implicit, instead of writing
\begin{equation}
  \sum_{m \models \varphi} \prod_{\ell \in m} w(\ell)
\end{equation}
we write
\begin{equation}
  \sum\prod \varphi.
\end{equation}
We provide a few supporting lemmata that follow directly from the model theory of Boolean functions.

\begin{lemma}\label{ind conj}[Independent Conjunction]
  Suppose $\varphi$ and $\psi$ Boolean formulae with nonintersecting variables. Then 
  \begin{equation}
    \sum\prod \varphi \land \psi = \paren{\sum\prod \varphi} \paren{\sum\prod \psi}.
  \end{equation}
\end{lemma}

\begin{lemma}\label{disj}[Inclusion-Exclusion]
  Suppose $\varphi$ and $\psi$ are Boolean formulae. Then
  \begin{equation}
    \sum\prod\varphi \lor \psi = \sum\prod \varphi + \sum\prod \psi - \sum\prod \varphi\land\psi.
  \end{equation}
\end{lemma}

\begin{lemma}\label{conditioning}[Conditioning]
  Suppose $\varphi$ a Boolean formula and $v$ a Boolean variable occurring in $\varphi$. Fix a weight function $w : lits(\varphi) \to \mathcal B$. Then we have
  \begin{equation}
    \sum\prod \varphi = \paren{\sum\prod (\varphi|_v \land v)} + \paren{\sum\prod (\varphi|_{\overline v} \land \overline v)}.
  \end{equation}
\end{lemma}

\subsection{The upper-bound algorithm}

Suppose $\varphi$ a Boolean formula over variables $V$ and $X \subseteq V$ as the setting of Definition \ref{BMSP BJSP}. We refer to an instantiation of a subset of variables of $X$ as a partial model.

\begin{figure}[H]
  \begin{subfigure}{1 \textwidth}
    \begin{mdframed}{\begin{algorithmic}[1]
      \Procedure{$ub$}{$\varphi, X, P, w$}
      \State $pm \gets \prod_{p \in P} w(p)$ 
      \State $acc \gets h(\varphi|_P, X, w)$
      \State \textbf{return} $pm \times acc$
      \EndProcedure
    \end{algorithmic}}
    \end{mdframed}
    \caption{The upper bound algorithm $ub$ takes in a formula $\varphi$, a subset $X \subseteq vars(\varphi)$, $P$ a partial model of $X$, and $w : lits(\varphi) \to \mathcal B$ a weight function.}
    \label{ub algo}
  \end{subfigure}
  \begin{subfigure}{1 \textwidth}
    \begin{mdframed}{\begin{algorithmic}[1]
      \Procedure{$h$}{$\varphi, X, w$}
      \If {$\varphi = \top$} \textbf{return} 1
      \ElsIf {$\varphi = \bot$} \textbf{return} 0
      \Else{ \textbf{choose} $v \in Vars(\varphi)$}
        \If{$v \in X$}  \textbf{return} $w(v)h(\varphi|_v) \sqcup w(\overline v)h(\varphi|_{\overline v}$)
        \Else{ \textbf{return} $w(v)h(\varphi|_v) + w(\overline v)h(\varphi|_{\overline v}$)}
        \EndIf
      \EndIf
      \EndProcedure
    \end{algorithmic}}
    \end{mdframed}
    \caption{The helper function $h$ as seen on Line 3 in the above algorithm.}
    \label{h algo}
  \end{subfigure}
  \caption{A single top-down pass upper-bound function.}
\end{figure}

What does $ub$ upper bound? The answer is subtle and we will first build supporting definitions and lemmata.

\begin{definition}
  Let $\varphi$ be a Boolean formula and $X \subseteq vars(\varphi)$. A \emph{partial model} of $X$ is an instantiation of variables $Y \subsetneq X$. A \emph{total model} of $X$ is an instantiation of $X$.
\end{definition}

\begin{lemma}\label{h invariant for total models}
  Let $\varphi$ be a formula and $X$ a set of Boolean variables disjoint from $vars(\varphi)$. Then for any weight function $w : lits(\varphi) \to \mathcal B$,
  \begin{equation}
    h(\varphi, X, w) = \sum\prod \varphi.
  \end{equation}
\end{lemma}

\begin{proof}
  The proof reduces to the fact that as long as Line 5 of $h$ (as seen in Algorithm \ref{h algo}) is never invoked, $h(\varphi, X,w)$ calculates the algebraic model count of $\varphi$ with respect to $w$.
\end{proof}

\begin{corollary}\label{ub invariant for total models}
  Let $\varphi$ be a formula and let $X \subseteq vars(\varphi)$. Let $P$ be a partial model of $X$ instantiating all variables of $X$. Let $w : lits(\varphi) \to \mathcal B$ be a weight function. Then
  \begin{equation}
    ub(\varphi, X, P, w) = \sum_{m \models \varphi|_P} \prod_{\ell \in m, P} w(\ell).
  \end{equation}
  In particular, if $f : inst(vars(\varphi)) \to \mathcal B$ is factorizable by $w$, we have
  \begin{equation}
    ub(\varphi, X, P, w) = \sum_{m \models \varphi|_P} f(m,P).
  \end{equation}
\end{corollary}

\begin{lemma}\label{upper bounds pm}
  Let $\varphi$ be a formula and let $X \subseteq vars(\varphi)$. Let $T$ be a total model of $X$. Then for any $P \subseteq T$, 
  \begin{equation}
    ub(\varphi, X, T \setminus P, w) \sqsupseteq ub(\varphi, X , T,w).
  \end{equation}
  In other words, every partial model upper-bounds its total extension.
\end{lemma}

\begin{proof}
  We induct simultaneously on the size of $P$ and $vars(\varphi)$. If $P = \eset$ or $vars(\varphi) = \eset$ the proof is trivial; assume as our inductive hypothesis that for all $P' \subsetneq P$
  \begin{equation}
    ub(\varphi, X, T\setminus P', w) \sqsupseteq ub(\varphi, X, T, w).\tag{IH}
  \end{equation}
  Unfolding we can recover
  \begin{equation}
    h(\varphi|_{T \setminus P'}) \sqsupseteq h(\varphi|_T)\prod_{x \in P'} w(x).\tag{IH}
  \end{equation}
  For the inductive case, it suffices to show
  \begin{equation}
    h(\varphi|_{T \setminus P}) \sqsupseteq h(\varphi|_T)\prod_{x \in P} w(x).
  \end{equation}
  let $x$ be the variable chosen by line 4 of Algorithm \ref{h algo}. We case.
  \begin{itemize}
    \item If $x \in P$, then in particular $x \in T$; we take the join as per line 5. We observe
    \begin{align*}
      h(\varphi|_{T \setminus P})
        &=w(x)h(\varphi|_{T \setminus P}|_x) \sqcup w(\overline x)h(\varphi|_{T \setminus P}|_{\overline x}) \\
        &=w(x)h(\varphi|_{T \setminus (P \setminus \{x\})}) \sqcup w(\overline x)h(\varphi|_{T \setminus P}|_{\overline x}) \\  
        &\sqsupseteq w(x)h(\varphi|_T)\prod_{y \in P\setminus \{x\}}w(y) \sqcup w(\overline x)h(\varphi|_{T \setminus P}|_{\overline x})&\text{(IH)}\\  
        &\sqsupseteq w(x)h(\varphi|_T)\prod_{y \in P\setminus \{x\}}w(x) = \boxed{h(\varphi|_T)\prod_{y \in P}w(x).}    
    \end{align*}
    \item If $x \notin P$, then we only need to consider the case when $x \notin T$ also; we take the sum as per line 6. We continue recursing until we hit a variable $x' \in P$; then we reduce to case 1 and we are done.
  \end{itemize}
\end{proof}

\textit{Remark.} It is important to note that the above lemma cannot be generalized to give a relation between two partial models $P \subsetneq P'$. This is because that the first inductive case crucially relies on the fact that we are not applying the IH twice. Indeed, in general,
\begin{align*}
   w(x)h(\varphi|_T)\prod_{y \in P\setminus \{x\}}w(y) \sqcup w(\overline x)h(\varphi|_T)\prod_{y \in P\setminus \{\overline x\}} w(y) \\\quad 
   \not\sqsupseteq \prod_{y \in P \setminus \{x, \overline x\}} w(y) \paren{w(x)h(\varphi|_T) \sqcup w(\overline x) h(\varphi|_T)}
\end{align*}
when $x \notin P'$; this is a manifestation of the more general phenomena that
$$a(b \sqcup c) \not \sqsubseteq ab \sqcup ac.$$

Now we can precisely define what \textit{exactly we are upper bounding.} The following theorem is a trivial application of Corrollary 1 and Lemma 6.

\begin{theorem}
  Fix $\varphi$ a Boolean formula and let $X \subseteq vars(\varphi)$. Let $P$ a partial model of $X$. Then, for any $T$ a total model extension of $P$,
  \begin{equation}
    ub(\varphi, X, P, w) \sqsupseteq \sum_{m \models T} \prod_{\ell \in m, T} w(\ell).
  \end{equation}
\end{theorem}

\subsection{The branch-and-bound algorithm}

\begin{figure}[H]
  \begin{mdframed}{\begin{algorithmic}[1]
    \Procedure{$bb$}{$\varphi, R, b, P_{curr}$}
    \If {$R = \eset$} 
      \State $u = ub(\varphi, X, P_{curr}, w)$ \Comment{$P_{curr}$ will be a total model}
      \State \textbf{return } $\max(u, b)$
    \Else
       \State $r = pop(R)$
       \For {$\ell \in \{r, \overline r\}$}
        \State $u = ub(\varphi, X, P_{curr} \cup \{\ell\},w)$
        \If {$u \not\sqsubseteq b$}
          \State $r = bb(\varphi, R, b, P_{curr} \cup \{\ell\})$ \Comment{$r$ will always be from a total model}
          \State $b = \max(r,b)$
        \EndIf
        \State \textbf{return } $b$
       \EndFor
    \EndIf
  \EndProcedure
  \end{algorithmic}}\end{mdframed}
  \caption{A branch-and-bound style algorithm calculating the max-sum problem. $\varphi$ is the Boolean formula with subset of variables $X$, $R$ is a tracker for branch-and-bound variables initialized as $X$, $b$ is a lower-bound initialized as $0$, and $P_{curr}$ is the current partial model.}
  \label{bb algo}
\end{figure}

\begin{lemma}\label{totality of bb}
  In Algorithm \ref{bb algo}, $b$ will always either be
  \begin{equation*}
    \text{(1)}\ \sum\prod \varphi|_T \quad \text{ for some total model $T$, or} \quad \text{(2)}\  0. 
  \end{equation*}
\end{lemma}

\begin{proof}
  The proof is a straightforward induction on $R$. 
\end{proof}

\begin{theorem}\label{soundness of bb}
  $bb(\varphi, X, 0, \eset) = MSP(\varphi).$
\end{theorem}

\begin{proof}
  It suffices to prove that $MSP(\varphi)$ is never pruned. That is, let $T_{MSP}$ be the total model witnessing $MSP(\varphi)$. We claim that $T_{MSP} = P_{curr}$ at some recursive call of $bb$. 

  Suppose not. Then, following line 9 of Algorithm \ref{bb algo}, there exists a partial model $P' \subset T_{MSP}$ such that $ub(\varphi, X, P', w) \sqsubseteq b$ for some $b$. By Lemma \ref{totality of bb}, we case on $b$.

  If $b=0$, then we have that $ub(\varphi, X, P', w)=0$. By Lemma \ref{upper bounds pm}, we have that then $\sum\prod \varphi|_{T_{MSP}} = 0$. But since this is the maximum such, we have that for all total models $T$ that $\sum\prod \varphi|_T=0$; thus we are done.

  If $b = \sum\prod \varphi|_T$ for some total model $T$, then we have that:
  \begin{equation*}
    \sum\prod \varphi|_{T_{MSP}} \sqsubseteq ub(\varphi, X, P', w) \sqsubseteq \sum\prod \varphi|_T.
  \end{equation*}
  By compatibility we have that
  \begin{equation*}
    \sum\prod \varphi|_{T_{MSP}} \leq \sum\prod \varphi|_T.
  \end{equation*}
  If the two sides are equal that means that $MSP(\varphi)$ has multiple witnesses, thus the branch was never pruned. Otherwise the contradiction is obvious and we are done.
\end{proof}
%% Acknowledgments
% \begin{acks}                            %% acks environment is optional
%                                         %% contents suppressed with 'anonymous'
%   %% Commands \grantsponsor{<sponsorID>}{<name>}{<url>} and
%   %% \grantnum[<url>]{<sponsorID>}{<number>} should be used to
%   %% acknowledge financial support and will be used by metadata
%   %% extraction tools.
%   This material is based upon work supported by the
%   \grantsponsor{GS100000001}{National Science
%     Foundation}{http://dx.doi.org/10.13039/100000001} under Grant
%   No.~\grantnum{GS100000001}{nnnnnnn} and Grant
%   No.~\grantnum{GS100000001}{mmmmmmm}.  Any opinions, findings, and
%   conclusions or recommendations expressed in this material are those
%   of the author and do not necessarily reflect the views of the
%   National Science Foundation.
% \end{acks}


%% Bibliography
% \bibliography{meu.bib}


% Appendix

\end{document}
